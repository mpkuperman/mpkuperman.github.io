---
title: How to optimize Julia SDEs?
date: 2021-12-29
permalink: /posts/2021/12/blog-post-3/
 
---

Hi all!. 
In this post I'll show how to optimize the simulation of a Stochastic Differential Equations System (SDEs) written in Julia Language. 
To that end I'll use the great DifferentialEquations.jl package. 

Firstly, stack and heap memory types will be defined. Then, the Longstaff-Schwartz SDEs system will be defined in two flavours: the in-place (iip) and out-of-place (oop) versions will be shown. For the oop system the StaticArrays.jl package will be used in order to provide stack allocated arrays. 
Finally the different defined SDEs will be benchmarked for adaptive and non-adaptive  in both heap allocations and elapsed time.

## Stack and Heap memory allocations

![image](https://i.stack.imgur.com/9c2VH.png)
Stack vs Heap ordering representation. Image taken from [this](https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap) stack overflow post.

Stack and heap both live in RAM memory. But they have some notorious differences. The Stack memory is ordered memory with simple allocation/deallocation patterns used for static allocation at compile time of constants, or even arrays. It is faster than the heap memory which is used for dynamic allocations that occur at runtime, allowing big arrays to be allocated when the compiling process of the code has been done. Unlike the Stack, the heap allows for allocations in any moment at the cost of less memory ordering, and of course less speed.
For example, in Python the memory is heap allocated due to that the type of the variables is only known at runtime. Furthermore, in Julia one can chose whether the memory is stack or heap allocated. In order to optimize Julia code we must ensure the most allocations are done in the stack at compile time. That is what we are going to do with the Longstaff-Schwartz system.


## Longstaff-Schwartz SDEs system
The Longstaff-Schwartz model is defined as a system of two mean reverting CIR-like Stochastic Differential Equations (SDEs). It can be written as follows:

![image](https://user-images.githubusercontent.com/29048170/147709341-01becdd8-385d-410b-95d8-813f4c66e4c9.png)

![image](https://user-images.githubusercontent.com/29048170/147709286-c674e73a-12c3-479f-9761-c3be389a36eb.png)

where <img src="https://latex.codecogs.com/svg.image?\kappa_i,&space;\theta_i,&space;\sigma_i&space;" title="\kappa_i, \theta_i, \sigma_i " /> are the mean reversion speed, leven and volatility of each SDE.


In julia there are some tricks to speed up calculations in the context of ODEs or SDEs. One way is define in-place (iip) functions with doesn't return anything, but that act mutating the values of a previously defined vector (du in this case). Another option is to define out-of-place (oop) functions that return static vectors which are stored in stack memory. The iip funcions for the L-S system can be written as:

```julia

 function f(du, u, p, t)
     @unpack κ₁, κ₂, θ₁, θ₂ = p

     du[1] = κ₁ * (θ₁ - u[1])
     du[2] = κ₂ * (θ₂ - u[2])
 end

 function g(du, u, p, t)
     @unpack σ₁, σ₂ = p

     du[1] = σ₁ * sqrt(u[1])
     du[2] = σ₂ * sqrt(u[2])
 end
  
```

Moreover, by using StaticArrays.jl we can define static vectors which are stored in the stack and are very rapid in many common operations. If we use the static arrays, our system can be defined as:

```julia

function f(u, p, t)
     @unpack κ₁, κ₂, θ₁, θ₂ = p

     du1 = κ₁ * (θ₁ - u[1])
     du2 = κ₂ * (θ₂ - u[2])

     @SVector [du1, du2]
 end

 function g(u, p, t)
     @unpack σ₁, σ₂ = p

     du1 = σ₁ * sqrt(u[1])
     du2 = σ₂ * sqrt(u[2])

     @SVector [du1, du2]
 end 

```

Finally, we need to define the initial condition for each SDE, the simulation time and the parameters. Note that for the oop system (i.e the one defined using the static vectors) we need to pass the initial condition as a static vector. We accomplish that by using the @SVector macro.

```julia

u0 = [0.1, 0.1]
u01 = @SVector [0.1, 0.1]

tspan = (0.0, 1.0)
p = (κ₁ = 0.1, κ₂ = 0.1, θ₁ = 0.1, θ₂ = 0.1, σ₁ = 0.1, σ₂ = 0.1)

ls_oop = SDEProblem{false}(f, g, u0, tspan, params)
ls_iip = SDEProblem{true}(f, g, u0, tspan, params)

```

## Benchmarking

I'll benchmark both the iip and oop systems in different situations. At first I'll compare the heap allcations and timing by using an adaptive discretization algorithm. Then I'll use the same algorithm but setting off the adaptativity feature. Finally, I'll use the Euler-Maruuyama scheme.


```julia

@btime solve(ls_iip)
@btime solve(ls_oop)

```

```julia

@btime solve(ls_iip, dt=1/252, adaptive=false)
@btime solve(ls_oop, dt=1/252, adaptive=false)

```

```julia

@btime solve(ls_iip, EM(), dt = 1 / 252)
@btime solve(ls_oop, EM(), dt = 1 / 252)

```

## Conclusions




